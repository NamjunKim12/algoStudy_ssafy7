> PR 제목은 문제명_이름으로 작성해주세요.

비밀이메일

## 🔗 문제 링크

https://www.acmicpc.net/problem/2999

### ✏ 나의 풀이

- 문제가 짧아서 쉬울 줄 알았는데 자세히 읽어보니 어려워보였다.

- 암호 해독방법이 복잡해보여서 풀 수 있을지 걱정이었다.

  [예상풀이]

1. 입력된 메시지의 길이를 구해서 그 값의 약수들을 구한다.
2. 그 약수들로 이루어진 배열을 만든 후, 배열의 길이/2 한 값을 r 로 두고, 메시지의 길이/r 의 값을 c로 둔다.(단 r>c일 경우에는 두 값을 서로 바꾼다.)
3. c행 r열의 배열을 만들어서 입력된 메시지를 c행 0열, c행 1열 ...  1행 r열까지 순서대로 넣는다.
4. r행 c열의 배열을 만들어 3.에서 만든 배열을 0행 0열, 0행 1열 ... r행 c열까지 순서대로 넣는다.(배열의 90도 회전)
5. 4.에서 만든 배열을 출력한다.

```JAVA

import java.util.Scanner;

public class Main {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		String M = sc.nextLine(); // 메시지 입력 받기
		String[] mArray = M.split(""); // 입력된 메시지의 길이 만큼의 배열 생성 후 메시지 값 넣기
		int factorNum = 0; // 약수의 개수

		for (int i = 1; i <= M.length(); i++) { // 1부터 메시지의 길이만큼 순회
			if (mArray.length % i == 0) { // i는 메시지 길이의 약수
				factorNum++; // 약수의 개수
			}
		}
		int[] factor = new int[factorNum]; // 약수의 개수 만큼의 배열 생성
		int idx = 0;
		for (int i = 1; i <= M.length(); i++) { // 1부터 메시지의 길이만큼 순회
			if (mArray.length % i == 0) { // i는 메시지 길이의 약수
				factor[idx] = i; // factor 배열의 값은 메시지 길이의 약수들
				idx++;
			}
		}
		int r = factor[factorNum / 2]; // 약수의 수/2의 인덱스 값에 위치한 값은 r(메시지 길이의 약수들을 크기순으로 배열했을 때 가장 중간에 있는 값을 r로 정하면 문제에서
										// 요구하는 r<=c 를 충족한다.
		int c = mArray.length / r; // r * c = 메시지의 길이 이므로!
		if (r > c) {
			r = c;
			c = factor[factorNum / 2];
		}
		// c행 r열의 배열 생성( r행 c열의 배열을 세로로 채워야 하므로 c행 r열의 배열을 만들어 c행부터 1행까지 값을 채워준 후
		// r행 c열의 배열을 만들어 값을 채워줄 것이다. (2차원 배열 90도 회전)
		String[][] deCode = new String[c][r];
		int k = 0;// 메시지의 길이값
		for (int i = c - 1; i >= 0; i--) {
			for (int j = 0; j < r; j++) {
				deCode[i][j] = mArray[k++];
			}
		}

		// 이제 시계방향으로 90도 회전!!
		String[][] result = new String[r][c];
		for (int i = 0; i < r; i++) {
			for (int j = 0; j < c; j++) {
				result[i][j] = deCode[c - 1 - j][i];

			}
		}
		// 이제 출력
		for (int i = 0; i < r; i++) {
			for (int j = 0; j < c; j++) {
				System.out.print(result[i][j]);
			}
		}

	}
}



```

### 😎 느낀 점 및 회고

문제를 처음 읽고 느꼈던 것보다는 어렵지 않았지만 중간중간 막히는 부분들이 있었다.

배열을 시계방향으로 90도 돌리기 위해 어떤 반복문과 조건문을 써야 하는지 알게 되었다. 

막상 코드를 보면 이해하기 쉬운데 그 코드를 작성하기까지가 쉽지 않았다.



이 난이도는 전체 알고리즘 문제들의 난이도로 보았을 때 쉬운 수준이라고 들었는데 나에게는 좀 어려웠다.

알고리즘 문제를 더 많이 풀어보면서 익혀야겠다.
